class ShukaApp { constructor() { this.isLoaded = false; this.observers = new Map(); this.init(); } init() { if (document.readyState === 'loading') { document.addEventListener('DOMContentLoaded', () => this.onDOMReady()); } else { this.onDOMReady(); } } onDOMReady() { this.setupIntersectionObserver(); this.setupFormHandling(); this.setupPerformanceOptimizations(); this.setupAccessibilityEnhancements(); this.setupErrorHandling(); this.isLoaded = true; document.dispatchEvent(new CustomEvent('shukaAppReady')); } setupIntersectionObserver() { const observerOptions = { threshold: 0.1, rootMargin: '0px 0px -50px 0px' }; const animationObserver = new IntersectionObserver((entries) => { entries.forEach(entry => { if (entry.isIntersecting) { this.animateElement(entry.target); } }); }, observerOptions); const animatedElements = document.querySelectorAll('.feature, .track, .about-visual, .contact-form'); animatedElements.forEach(el => { animationObserver.observe(el); }); this.observers.set('animation', animationObserver); } animateElement(element) { if (window.matchMedia('(prefers-reduced-motion: reduce)').matches) { element.style.opacity = '1'; element.style.transform = 'none'; return; } if (element.classList.contains('feature')) { element.classList.add('animate-slide-in-left'); } else if (element.classList.contains('about-visual')) { element.classList.add('animate-slide-in-right'); } else { element.classList.add('animate-fade-in'); } setTimeout(() => { element.classList.remove('animate-slide-in-left', 'animate-slide-in-right', 'animate-fade-in'); }, 600); } setupFormHandling() { const contactForm = document.querySelector('.contact-form'); if (contactForm) { contactForm.addEventListener('submit', (e) => this.handleFormSubmit(e)); const inputs = contactForm.querySelectorAll('input, textarea'); inputs.forEach(input => { input.addEventListener('blur', () => this.validateField(input)); input.addEventListener('input', () => this.clearFieldError(input)); }); } } handleFormSubmit(e) { e.preventDefault(); const form = e.target; if (!this.validateForm(form)) { return; } this.setFormLoadingState(form, true); setTimeout(() => { this.showFormSuccess(form); this.setFormLoadingState(form, false); form.reset(); }, 2000); } validateForm(form) { const requiredFields = form.querySelectorAll('[required]'); let isValid = true; requiredFields.forEach(field => { if (!this.validateField(field)) { isValid = false; } }); return isValid; } validateField(field) { const value = field.value.trim(); const fieldType = field.type; let isValid = true; let errorMessage = ''; if (field.hasAttribute('required') && !value) { isValid = false; errorMessage = 'この項目は必須です'; } if (fieldType === 'email' && value) { const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/; if (!emailRegex.test(value)) { isValid = false; errorMessage = 'メールアドレスの形式が正しくありません'; } } this.showFieldError(field, isValid ? '' : errorMessage); return isValid; } showFieldError(field, message) { this.clearFieldError(field); if (message) { field.classList.add('error'); field.setAttribute('aria-invalid', 'true'); const errorElement = document.createElement('div'); errorElement.className = 'field-error'; errorElement.textContent = message; errorElement.id = `${field.id}-error`; field.setAttribute('aria-describedby', errorElement.id); field.parentNode.appendChild(errorElement); } } clearFieldError(field) { field.classList.remove('error'); field.removeAttribute('aria-invalid'); field.removeAttribute('aria-describedby'); const existingError = field.parentNode.querySelector('.field-error'); if (existingError) { existingError.remove(); } } setFormLoadingState(form, isLoading) { const submitButton = form.querySelector('.form-submit'); const inputs = form.querySelectorAll('input, textarea, button'); if (isLoading) { submitButton.textContent = '送信中...'; submitButton.disabled = true; inputs.forEach(input => input.disabled = true); } else { submitButton.textContent = '送信する'; submitButton.disabled = false; inputs.forEach(input => input.disabled = false); } } showFormSuccess(form) { const successMessage = document.createElement('div'); successMessage.className = 'form-success'; successMessage.innerHTML = ` <div class="success-content"> <span class="success-icon">✓</span> <p>お問い合わせありがとうございます。<br>お返事まで今しばらくお待ちください。</p> </div> `; form.style.display = 'none'; form.parentNode.appendChild(successMessage); setTimeout(() => { successMessage.remove(); form.style.display = 'block'; }, 5000); } setupPerformanceOptimizations() { if ('IntersectionObserver' in window) { const imageObserver = new IntersectionObserver((entries) => { entries.forEach(entry => { if (entry.isIntersecting) { const img = entry.target; if (img.dataset.src) { img.src = img.dataset.src; img.removeAttribute('data-src'); imageObserver.unobserve(img); } } }); }); const lazyImages = document.querySelectorAll('img[data-src]'); lazyImages.forEach(img => imageObserver.observe(img)); this.observers.set('images', imageObserver); } document.addEventListener('mouseover', this.preloadOnHover, { once: true }); document.addEventListener('touchstart', () => this.preloadOnTouch(), { once: true }); } preloadOnHover() { const seasonImages = [ './img/秀歌-春.webp', './img/秀歌-夏.webp', './img/秀歌-秋.webp', './img/秀歌-冬.webp' ]; seasonImages.forEach(src => { const link = document.createElement('link'); link.rel = 'prefetch'; link.href = src; document.head.appendChild(link); }); } preloadOnTouch() { this.preloadOnHover(); } setupAccessibilityEnhancements() { const skipLinks = document.querySelectorAll('.skip-link'); skipLinks.forEach(link => { link.addEventListener('click', (e) => { e.preventDefault(); const targetId = link.getAttribute('href').substring(1); const target = document.getElementById(targetId); if (target) { target.focus(); target.scrollIntoView(); } }); }); document.addEventListener('keydown', (e) => { if (e.key === 'Tab') { this.handleTabKey(e); } }); this.setupRouteAnnouncements(); } handleTabKey(e) { const activeModal = document.querySelector('.modal.active'); if (activeModal) { this.trapFocus(e, activeModal); } } trapFocus(e, container) { const focusableElements = container.querySelectorAll( 'a, button, input, textarea, select, [tabindex]:not([tabindex="-1"])' ); const firstFocusable = focusableElements[0]; const lastFocusable = focusableElements[focusableElements.length - 1]; if (e.shiftKey) { if (document.activeElement === firstFocusable) { e.preventDefault(); lastFocusable.focus(); } } else { if (document.activeElement === lastFocusable) { e.preventDefault(); firstFocusable.focus(); } } } setupRouteAnnouncements() { window.addEventListener('hashchange', () => { const hash = window.location.hash.substring(1); if (hash) { const section = document.getElementById(hash); if (section) { const heading = section.querySelector('h1, h2, h3'); if (heading) { this.announceToScreenReader(`${heading.textContent}セクションに移動しました`); } } } }); } announceToScreenReader(message) { let announcer = document.getElementById('screen-reader-announcer'); if (!announcer) { announcer = document.createElement('div'); announcer.id = 'screen-reader-announcer'; announcer.setAttribute('aria-live', 'polite'); announcer.setAttribute('aria-atomic', 'true'); announcer.className = 'visually-hidden'; document.body.appendChild(announcer); } announcer.textContent = message; } setupErrorHandling() { window.addEventListener('error', (e) => { console.error('Global error:', e.error); }); window.addEventListener('unhandledrejection', (e) => { console.error('Unhandled promise rejection:', e.reason); }); } debounce(func, wait) { let timeout; return function executedFunction(...args) { const later = () => { clearTimeout(timeout); func(...args); }; clearTimeout(timeout); timeout = setTimeout(later, wait); }; } throttle(func, limit) { let inThrottle; return function() { const args = arguments; const context = this; if (!inThrottle) { func.apply(context, args); inThrottle = true; setTimeout(() => inThrottle = false, limit); } }; } destroy() { this.observers.forEach(observer => observer.disconnect()); this.observers.clear(); }}window.shukaApp = new ShukaApp();const additionalCSS = ` .field-error { color: var(--accent); font-size: var(--text-sm); margin-top: var(--space-1); } .form-input.error, .form-textarea.error { border-color: var(--accent); box-shadow: 0 0 0 3px rgba(236, 72, 153, 0.1); } .form-success { background: var(--spring); color: white; padding: var(--space-8); border-radius: var(--radius-xl); text-align: center; animation: fadeIn 0.5s ease-out; } .success-content { display: flex; flex-direction: column; align-items: center; gap: var(--space-4); } .success-icon { font-size: var(--text-4xl); width: 60px; height: 60px; background: rgba(255, 255, 255, 0.2); border-radius: var(--radius-full); display: flex; align-items: center; justify-content: center; } .track.playing { background: var(--primary-light); color: white; }`;const additionalStyle = document.createElement('style');additionalStyle.textContent = additionalCSS;document.head.appendChild(additionalStyle);export { ShukaApp };class Navigation { constructor() { this.navToggle = document.getElementById('nav-toggle'); this.navMenu = document.getElementById('nav-menu'); this.navLinks = document.querySelectorAll('.nav-menu a[href^="#"]'); this.header = document.getElementById('header'); this.init(); } init() { this.bindEvents(); this.handleScroll(); } bindEvents() { if (this.navToggle) { this.navToggle.addEventListener('click', () => this.toggleMobileMenu()); } this.navLinks.forEach(link => { link.addEventListener('click', (e) => this.handleSmoothScroll(e)); }); document.addEventListener('click', (e) => this.handleOutsideClick(e)); window.addEventListener('scroll', () => this.handleScroll()); document.addEventListener('keydown', (e) => this.handleEscapeKey(e)); } toggleMobileMenu() { const isActive = this.navMenu.classList.contains('active'); if (isActive) { this.closeMobileMenu(); } else { this.openMobileMenu(); } } openMobileMenu() { this.navMenu.classList.add('active'); if (this.navToggle) { this.navToggle.classList.add('active'); this.navToggle.setAttribute('aria-expanded', 'true'); this.navToggle.setAttribute('aria-label', 'メニューを閉じる'); } document.body.style.overflow = 'hidden'; const firstFocusableElement = this.navMenu.querySelector('a, button'); if (firstFocusableElement) { firstFocusableElement.focus(); } } closeMobileMenu() { this.navMenu.classList.remove('active'); if (this.navToggle) { this.navToggle.classList.remove('active'); this.navToggle.setAttribute('aria-expanded', 'false'); this.navToggle.setAttribute('aria-label', 'メニューを開く'); } document.body.style.overflow = ''; if (this.navToggle) { this.navToggle.focus(); } } handleSmoothScroll(e) { e.preventDefault(); const targetId = e.target.getAttribute('href').substring(1); const targetElement = document.getElementById(targetId); if (targetElement) { if (this.navMenu.classList.contains('active')) { this.closeMobileMenu(); } const headerHeight = this.header.offsetHeight; const targetPosition = targetElement.offsetTop - headerHeight; window.scrollTo({ top: targetPosition, behavior: 'smooth' }); history.pushState(null, null, `#${targetId}`); this.updateActiveNavLink(targetId); } } smoothScrollTo(targetPosition) { const startPosition = window.pageYOffset; const distance = targetPosition - startPosition; const duration = 400; let start = null; const animation = (currentTime) => { if (start === null) start = currentTime; const timeElapsed = currentTime - start; const progress = Math.min(timeElapsed / duration, 1); const easeInOutCubic = progress < 0.5 ? 4 * progress * progress * progress : (progress - 1) * (2 * progress - 2) * (2 * progress - 2) + 1; window.scrollTo(0, startPosition + distance * easeInOutCubic); if (timeElapsed < duration) { requestAnimationFrame(animation); } }; requestAnimationFrame(animation); } updateActiveNavLink(activeId) { this.navLinks.forEach(link => { const href = link.getAttribute('href').substring(1); if (href === activeId) { link.classList.add('active'); link.setAttribute('aria-current', 'page'); } else { link.classList.remove('active'); link.removeAttribute('aria-current'); } }); } handleOutsideClick(e) { const isClickInsideNav = this.navMenu.contains(e.target) || (this.navToggle && this.navToggle.contains(e.target)); if (!isClickInsideNav && this.navMenu.classList.contains('active')) { this.closeMobileMenu(); } } handleEscapeKey(e) { if (e.key === 'Escape' && this.navMenu.classList.contains('active')) { this.closeMobileMenu(); } } handleScroll() { const scrolled = window.pageYOffset; const threshold = 100; if (scrolled > threshold) { this.header.classList.add('scrolled'); } else { this.header.classList.remove('scrolled'); } this.updateActiveNavOnScroll(); } updateActiveNavOnScroll() { const sections = ['home', 'about', 'gallery', 'contact']; const headerHeight = this.header.offsetHeight; const scrollPosition = window.pageYOffset + headerHeight + 100; let activeSection = 'home'; for (const sectionId of sections) { const section = document.getElementById(sectionId); if (section && scrollPosition >= section.offsetTop) { activeSection = sectionId; } } this.updateActiveNavLink(activeSection); }}window.scrollToSection = function(sectionId) { const targetElement = document.getElementById(sectionId); const header = document.getElementById('header'); if (targetElement && header) { const headerHeight = header.offsetHeight; const targetPosition = targetElement.offsetTop - headerHeight; window.scrollTo({ top: targetPosition, behavior: 'smooth' }); }};window.Navigation = Navigation;window.scrollToSection = scrollToSection;class SeasonsGallery { constructor() { this.seasonButtons = document.querySelectorAll('.season-btn'); this.seasonPanels = document.querySelectorAll('.season-panel'); this.currentSeason = 'tsuyu'; this.audioElements = []; this.videoElements = []; this.init(); } init() { this.bindEvents(); this.setupAudioElements(); this.preloadWashiBackgrounds(); this.loadInitialSeason(); } bindEvents() { this.seasonButtons.forEach(button => { button.addEventListener('click', (e) => this.handleSeasonChange(e)); button.addEventListener('keydown', (e) => this.handleKeyboardNavigation(e)); }); document.addEventListener('play', (e) => this.handleAudioPlay(e), true); document.addEventListener('pause', (e) => this.handleAudioPause(e), true); } setupAudioElements() { this.audioElements = Array.from(document.querySelectorAll('audio')); this.videoElements = Array.from(document.querySelectorAll('video')); this.audioElements.forEach(audio => { audio.preload = 'none'; const trackTitleEl = audio.parentElement.querySelector('.track-title'); const trackTitle = trackTitleEl ? trackTitleEl.textContent : 'Track'; audio.setAttribute('aria-label', `${trackTitle}の音楽プレーヤー`); }); this.videoElements.forEach(video => { video.volume = 0.5; video.preload = 'none'; video.muted = false; video.addEventListener('click', (e) => this.handleVideoClick(e)); video.addEventListener('keydown', (e) => this.handleVideoKeydown(e)); const container = video.closest('.season-visual'); if (container && !container.dataset.playHandlerAdded) { container.addEventListener('click', (ev) => { if (ev.target === video) return; if (video.paused) { video.play().catch(err => { console.error('Video play failed:', err); }); } }); container.dataset.playHandlerAdded = 'true'; } const seasonPanel = video.closest('.season-panel'); const seasonTitleEl = seasonPanel ? seasonPanel.querySelector('.season-title') : null; const seasonTitle = seasonTitleEl ? seasonTitleEl.textContent : 'Video'; video.setAttribute('aria-label', `${seasonTitle}のデモ動画`); }); } preloadWashiBackgrounds() { const washiImages = [ './img/和紙-春.webp', './img/和紙-夏.webp', './img/和紙-秋.webp', './img/和紙-冬.webp', './img/和紙-梅雨.webp' ]; washiImages.forEach(src => { const img = new Image(); img.src = src; }); } loadInitialSeason() { this.currentSeason = 'winter'; this.updateSeasonBackground('winter'); if (typeof window.enableSnow === 'function') { window.enableSnow(); } this.updateURL('winter'); this.updateSeasonButtons('winter'); this.updateSeasonPanels('winter', false); } getSeasonFromURL() { const urlParams = new URLSearchParams(window.location.search); const season = urlParams.get('season'); if (['spring', 'summer', 'autumn', 'winter', 'tsuyu'].includes(season)) { return season; } return null; } getSeasonFromDate() { const now = new Date(); const month = now.getMonth() + 1; if (month >= 3 && month <= 5) return 'spring'; if (month >= 6 && month <= 8) return 'summer'; if (month >= 9 && month <= 11) return 'autumn'; return 'winter'; } handleSeasonChange(e) { e.preventDefault(); const button = e.currentTarget; const season = button.getAttribute('data-season'); if (season && season !== this.currentSeason) { this.switchToSeason(season); } } handleKeyboardNavigation(e) { const currentIndex = Array.from(this.seasonButtons).indexOf(e.currentTarget); let nextIndex = currentIndex; switch (e.key) { case 'ArrowRight': case 'ArrowDown': e.preventDefault(); nextIndex = (currentIndex + 1) % this.seasonButtons.length; break; case 'ArrowLeft': case 'ArrowUp': e.preventDefault(); nextIndex = (currentIndex - 1 + this.seasonButtons.length) % this.seasonButtons.length; break; case 'Home': e.preventDefault(); nextIndex = 0; break; case 'End': e.preventDefault(); nextIndex = this.seasonButtons.length - 1; break; case 'Enter': case ' ': e.preventDefault(); this.handleSeasonChange(e); return; default: return; } this.seasonButtons[nextIndex].focus(); } switchToSeason(season, animate = true) { if (!['spring', 'summer', 'autumn', 'winter', 'tsuyu'].includes(season)) { console.error(`Invalid season: ${season}`); return; } this.stopAllAudio(); this.updateSeasonButtons(season); this.updateSeasonPanels(season, animate); const previousSeason = this.currentSeason; this.currentSeason = season; this.updateURL(season); if (animate) { this.updateHeroBackground(season); } this.updateSeasonBackground(season); if (season === 'spring') { if (typeof window.disableRain === 'function') { window.disableRain(); } if (typeof window.disableSnow === 'function') { window.disableSnow(); } if (typeof window.disableAutumnLeaves === 'function') { window.disableAutumnLeaves(); } if (typeof window.disableSummerWillow === 'function') { window.disableSummerWillow(); } } else if (season === 'tsuyu') { if (typeof window.enableRain === 'function') { window.enableRain(); } if (typeof window.disableSnow === 'function') { window.disableSnow(); } } else if (season === 'winter') { if (typeof window.enableSnow === 'function') { window.enableSnow(); } if (typeof window.disableRain === 'function') { window.disableRain(); } if (typeof window.disableAutumnLeaves === 'function') { window.disableAutumnLeaves(); } if (typeof window.disableSummerWillow === 'function') { window.disableSummerWillow(); } } else if (season === 'autumn') { if (typeof window.enableAutumnLeaves === 'function') { window.enableAutumnLeaves(); } if (typeof window.disableRain === 'function') { window.disableRain(); } if (typeof window.disableSnow === 'function') { window.disableSnow(); } if (typeof window.disableSummerWillow === 'function') { window.disableSummerWillow(); } } else if (season === 'summer') { if (typeof window.enableSummerWillow === 'function') { window.enableSummerWillow(); } if (typeof window.disableRain === 'function') { window.disableRain(); } if (typeof window.disableSnow === 'function') { window.disableSnow(); } if (typeof window.disableAutumnLeaves === 'function') { window.disableAutumnLeaves(); } } else { if (typeof window.disableRain === 'function') { window.disableRain(); } if (typeof window.disableSnow === 'function') { window.disableSnow(); } if (typeof window.disableAutumnLeaves === 'function') { window.disableAutumnLeaves(); } if (typeof window.disableSummerWillow === 'function') { window.disableSummerWillow(); } } this.announceSeasonChange(season); } updateSeasonButtons(activeSeason) { this.seasonButtons.forEach(button => { const buttonSeason = button.getAttribute('data-season'); const isActive = buttonSeason === activeSeason; button.classList.toggle('active', isActive); button.setAttribute('aria-selected', isActive.toString()); if (isActive) { button.setAttribute('tabindex', '0'); } else { button.setAttribute('tabindex', '-1'); } }); } updateSeasonPanels(activeSeason, animate) { this.seasonPanels.forEach(panel => { const panelSeason = panel.getAttribute('data-season'); const isActive = panelSeason === activeSeason; if (isActive) { this.showPanel(panel, animate); } else { this.hidePanel(panel, animate); } }); } showPanel(panel, animate) { panel.style.display = 'grid'; panel.classList.add('active'); if (animate) { panel.style.opacity = '0'; panel.style.transform = 'scale(0.97)'; panel.style.transition = 'opacity 0.4s ease, transform 0.4s ease'; requestAnimationFrame(() => { panel.style.opacity = '1'; panel.style.transform = 'scale(1)'; }); setTimeout(() => { panel.style.transition = ''; panel.style.opacity = ''; panel.style.transform = ''; }, 400); this.animatePanelChildren(panel, true); } panel.setAttribute('aria-hidden', 'false'); } hidePanel(panel, animate) { if (animate) { this.animatePanelChildren(panel, false); panel.style.transition = 'opacity 0.3s ease, transform 0.3s ease'; panel.style.opacity = '0'; panel.style.transform = 'scale(0.97)'; setTimeout(() => { panel.style.transition = ''; panel.style.display = 'none'; panel.classList.remove('active'); panel.style.opacity = ''; panel.style.transform = ''; }, 300); } else { panel.style.display = 'none'; panel.classList.remove('active'); } panel.setAttribute('aria-hidden', 'true'); } updateURL(season) { const url = new URL(window.location); url.searchParams.set('season', season); history.replaceState(null, '', url.toString()); } updateSeasonBackground(season) { const washiImages = { spring: './img/和紙-春.webp', summer: './img/和紙-夏.webp', autumn: './img/和紙-秋.webp', winter: './img/和紙-冬.webp', tsuyu: './img/和紙-梅雨.webp' }; const colorVars = { spring: ['--primary-spring', '--accent-spring'], summer: ['--primary-summer', '--accent-summer'], autumn: ['--primary-autumn', '--accent-autumn'], winter: ['--primary-winter', '--accent-winter'], tsuyu: ['--primary-tsuyu', '--accent-tsuyu'] }; const root = document.documentElement; const computed = getComputedStyle(root); const vars = colorVars[season]; if (vars) { const primaryColor = computed.getPropertyValue(vars[0]).trim(); const accentColor = computed.getPropertyValue(vars[1]).trim(); root.style.setProperty('--primary', primaryColor); root.style.setProperty('--accent', accentColor); } const imageUrl = washiImages[season]; if (imageUrl) { const img = new Image(); img.onload = () => { document.body.setAttribute('data-season', season); const header = document.getElementById('header'); if (header) header.setAttribute('data-season', season); const selector = document.getElementById('season-selector'); if (selector && typeof selector.updateActive === 'function') selector.updateActive(season); }; img.src = imageUrl; } else { document.body.setAttribute('data-season', season); const header = document.getElementById('header'); if (header) header.setAttribute('data-season', season); const selector = document.getElementById('season-selector'); if (selector && typeof selector.updateActive === 'function') selector.updateActive(season); } this.updateFavicon(season); } updateFavicon(season) { const icons = { spring: '🌸', tsuyu: '☔️', summer: '🌻', autumn: '🍁', winter: '❄️' }; const emoji = icons[season] || '🌸'; const svg = encodeURIComponent( `<svg xmlns="http: ); let link = document.querySelector('link[rel="icon"]'); if (!link) { link = document.createElement('link'); link.rel = 'icon'; document.head.appendChild(link); } link.setAttribute('href', `data:image/svg+xml,${svg}`); } updateHeroBackground(season) { const hero = document.querySelector('.hero'); if (!hero) return; const seasonImages = { spring: './img/秀歌-春.webp', summer: './img/秀歌-夏.webp', autumn: './img/秀歌-秋.webp', winter: './img/秀歌-冬.webp', tsuyu: './img/秀歌-梅雨.webp' }; const imageUrl = seasonImages[season]; if (imageUrl) { const img = new Image(); img.onload = () => { hero.style.backgroundImage = `linear-gradient(rgba(0,0,0,0.4), rgba(0,0,0,0.4)), url('${imageUrl}')`; hero.style.backgroundPosition = 'top center'; const heroContent = hero.querySelector('.hero-content'); if (heroContent) { heroContent.style.paddingTop = '35vh'; } }; img.src = imageUrl; } } announceSeasonChange(season) { const seasonNames = { spring: '春', summer: '夏', autumn: '秋', winter: '冬', tsuyu: '梅雨' }; const announcement = `${seasonNames[season]}の楽曲に切り替わりました`; let liveRegion = document.getElementById('season-announcer'); if (!liveRegion) { liveRegion = document.createElement('div'); liveRegion.id = 'season-announcer'; liveRegion.setAttribute('aria-live', 'polite'); liveRegion.setAttribute('aria-atomic', 'true'); liveRegion.className = 'visually-hidden'; document.body.appendChild(liveRegion); } liveRegion.textContent = announcement; } handleAudioPlay(e) { if (e.target.tagName === 'AUDIO') { this.audioElements.forEach(audio => { if (audio !== e.target && !audio.paused) { this.fadeOutAndPause(audio); } }); this.fadeInAudio(e.target); const trackEl = e.target.closest('.track'); if (trackEl) trackEl.classList.add('playing'); } } handleAudioPause(e) { if (e.target.tagName === 'AUDIO') { const trackEl = e.target.closest('.track'); if (trackEl) trackEl.classList.remove('playing'); } } handleVideoClick(e) { const video = e.target; if (video.paused) { video.play().catch(error => { console.error('Video play failed:', error); }); } else { video.pause(); } e.preventDefault(); } handleVideoKeydown(e) { const video = e.target; if (e.code === 'Space' || e.code === 'Enter') { e.preventDefault(); this.handleVideoClick(e); } if (e.code === 'ArrowLeft') { e.preventDefault(); video.currentTime = Math.max(0, video.currentTime - 5); } if (e.code === 'ArrowRight') { e.preventDefault(); video.currentTime = Math.min(video.duration, video.currentTime + 5); } } animatePanelChildren(panel, isEntering) { const videoElement = panel.querySelector('.season-visual'); const trackList = panel.querySelector('.season-tracks'); const seasonTitle = panel.querySelector('.season-title'); const seasonDesc = panel.querySelector('.season-description'); if (isEntering) { if (videoElement) { videoElement.style.opacity = '0'; videoElement.style.transform = 'translateX(-80px)'; videoElement.style.transition = 'opacity 0.7s cubic-bezier(0.25, 0.1, 0.25, 1) 0.1s, transform 0.7s cubic-bezier(0.25, 0.1, 0.25, 1) 0.1s'; requestAnimationFrame(() => { videoElement.style.opacity = '1'; videoElement.style.transform = 'translateX(0)'; }); setTimeout(() => { videoElement.style.transition = ''; videoElement.style.opacity = ''; videoElement.style.transform = ''; }, 800); } if (trackList) { [seasonTitle, seasonDesc].forEach((element, index) => { if (element) { element.style.opacity = '0'; element.style.transform = 'translateX(60px)'; element.style.transition = `opacity 0.6s cubic-bezier(0.25, 0.1, 0.25, 1) ${0.2 + (index * 0.1)}s, transform 0.6s cubic-bezier(0.25, 0.1, 0.25, 1) ${0.2 + (index * 0.1)}s`; requestAnimationFrame(() => { element.style.opacity = '1'; element.style.transform = 'translateX(0)'; }); setTimeout(() => { element.style.transition = ''; element.style.opacity = ''; element.style.transform = ''; }, 700 + (index * 100)); } }); trackList.style.opacity = '0'; trackList.style.transform = 'translateX(100px)'; trackList.style.transition = 'opacity 0.8s cubic-bezier(0.25, 0.1, 0.25, 1) 0.3s, transform 0.8s cubic-bezier(0.25, 0.1, 0.25, 1) 0.3s'; requestAnimationFrame(() => { trackList.style.opacity = '1'; trackList.style.transform = 'translateX(0)'; }); setTimeout(() => { trackList.style.transition = ''; trackList.style.opacity = ''; trackList.style.transform = ''; }, 1100); const tracks = trackList.querySelectorAll('.track'); tracks.forEach((track, trackIndex) => { track.style.opacity = '0'; track.style.transform = 'translateX(40px)'; track.style.transition = `opacity 0.5s cubic-bezier(0.25, 0.1, 0.25, 1) ${0.5 + (trackIndex * 0.08)}s, transform 0.5s cubic-bezier(0.25, 0.1, 0.25, 1) ${0.5 + (trackIndex * 0.08)}s`; requestAnimationFrame(() => { track.style.opacity = '1'; track.style.transform = 'translateX(0)'; }); setTimeout(() => { track.style.transition = ''; track.style.opacity = ''; track.style.transform = ''; }, 1000 + (trackIndex * 80)); }); } } else { if (videoElement) { videoElement.style.transition = 'opacity 0.4s cubic-bezier(0.25, 0.1, 0.25, 1), transform 0.4s cubic-bezier(0.25, 0.1, 0.25, 1)'; videoElement.style.opacity = '0'; videoElement.style.transform = 'translateX(-60px)'; } if (trackList) { const tracks = trackList.querySelectorAll('.track'); tracks.forEach((track, trackIndex) => { track.style.transition = `opacity 0.3s cubic-bezier(0.25, 0.1, 0.25, 1) ${trackIndex * 0.03}s, transform 0.3s cubic-bezier(0.25, 0.1, 0.25, 1) ${trackIndex * 0.03}s`; track.style.opacity = '0'; track.style.transform = 'translateX(30px)'; }); [seasonTitle, seasonDesc, trackList].forEach((element, index) => { if (element) { element.style.transition = `opacity 0.4s cubic-bezier(0.25, 0.1, 0.25, 1) ${0.1 + (index * 0.05)}s, transform 0.4s cubic-bezier(0.25, 0.1, 0.25, 1) ${0.1 + (index * 0.05)}s`; element.style.opacity = '0'; element.style.transform = 'translateX(50px)'; } }); } } } fadeOutAndPause(audio, duration = 500) { const start = audio.volume; const step = start / (duration / 50); const fade = setInterval(() => { if (audio.volume > step) { audio.volume = Math.max(0, audio.volume - step); } else { clearInterval(fade); audio.pause(); audio.currentTime = 0; audio.volume = start; } }, 50); } fadeInAudio(audio, target = 0.5, duration = 500) { audio.volume = 0; const step = target / (duration / 50); const fade = setInterval(() => { if (audio.volume < target - step) { audio.volume = Math.min(target, audio.volume + step); } else { audio.volume = target; clearInterval(fade); } }, 50); } stopAllAudio() { this.audioElements.forEach(audio => { if (!audio.paused) { this.fadeOutAndPause(audio); } }); } getCurrentSeason() { return this.currentSeason; } getAvailableSeasons() { return ['spring', 'summer', 'autumn', 'winter']; }}function switchSeason(season) { if (window.seasonsGallery && typeof window.seasonsGallery.switchToSeason === 'function') { window.seasonsGallery.switchToSeason(season); }}window.SeasonsGallery = SeasonsGallery;window.switchSeason = switchSeason;function initSeasonSelector() { const selector = document.getElementById('season-selector'); if (!selector) return; const buttons = selector.querySelectorAll('button[data-season]'); selector.updateActive = (season) => { buttons.forEach(btn => { const isActive = btn.getAttribute('data-season') === season; btn.classList.toggle('active', isActive); btn.setAttribute('aria-checked', isActive); }); }; if (window.seasonsGallery && typeof window.seasonsGallery.getCurrentSeason === 'function') { selector.updateActive(window.seasonsGallery.getCurrentSeason()); } selector.addEventListener('click', (e) => { const button = e.target.closest('button[data-season]'); if (!button) return; const season = button.getAttribute('data-season'); if (typeof window.switchSeason === 'function') { window.switchSeason(season); } });}window.initSeasonSelector = initSeasonSelector;'use strict';class SnowEffect { constructor() { this.canvas = document.createElement('canvas'); this.canvas.className = 'snow-canvas'; this.ctx = this.canvas.getContext('2d'); document.body.appendChild(this.canvas); this.resize(); this.sizeMultiplier = this.getSizeMultiplier(); window.addEventListener('resize', () => this.resize()); this.flakes = []; this.flakeCount = Math.floor(window.innerWidth / 8); for (let i = 0; i < this.flakeCount; i++) { this.flakes.push(this.createFlake(true)); } this.handleMouseMove = this.handleMouseMove.bind(this); window.addEventListener('mousemove', this.handleMouseMove); window.addEventListener('touchmove', (e) => { if (e.touches && e.touches[0]) { this.handleMouseMove(e.touches[0]); } }, { passive: true }); this.wind = 0; this.windTarget = 0; this.lastWindChange = performance.now(); this.animate = this.animate.bind(this); requestAnimationFrame(this.animate); } resize() { this.canvas.width = window.innerWidth; this.canvas.height = window.innerHeight; this.sizeMultiplier = this.getSizeMultiplier(); } getSizeMultiplier() { const ratio = window.innerWidth / 768; return Math.min(Math.max(ratio, 0.6), 1.2); } createFlake(randomY = false) { return { x: Math.random() * this.canvas.width, y: randomY ? Math.random() * this.canvas.height : -20, size: (2 + Math.random() * 6) * this.sizeMultiplier, speed: 0.5 + Math.random() * 1.5, opacity: 0.4 + Math.random() * 0.6, drift: Math.random() * 0.5 - 0.25, rotationSpeed: (Math.random() - 0.5) * 2, rotation: 0 }; } handleMouseMove(e) { const centerX = window.innerWidth / 2; const normalized = (e.clientX - centerX) / centerX; this.windTarget = normalized * 0.5; } animate() { const ctx = this.ctx; ctx.clearRect(0, 0, this.canvas.width, this.canvas.height); const now = performance.now(); if (now - this.lastWindChange > 4000) { this.windTarget = (Math.random() * 2 - 1) * 0.5; this.lastWindChange = now; } this.wind += (this.windTarget - this.wind) * 0.01; for (const flake of this.flakes) { ctx.globalAlpha = flake.opacity; ctx.fillStyle = `rgba(255, 255, 255, ${flake.opacity})`; ctx.save(); ctx.translate(flake.x, flake.y); ctx.rotate(flake.rotation); if (flake.size > 4) { this.drawStar(ctx, 0, 0, flake.size / 2, flake.size / 4, 6); } else { ctx.beginPath(); ctx.arc(0, 0, flake.size / 2, 0, Math.PI * 2); ctx.fill(); } ctx.restore(); flake.x += this.wind + flake.drift; flake.y += flake.speed; flake.rotation += flake.rotationSpeed * 0.02; if (flake.x < -20) flake.x = this.canvas.width + 20; if (flake.x > this.canvas.width + 20) flake.x = -20; if (flake.y > this.canvas.height + 20) { Object.assign(flake, this.createFlake()); } } requestAnimationFrame(this.animate); } drawStar(ctx, cx, cy, outerRadius, innerRadius, spikes) { let rot = Math.PI / 2 * 3; let x = cx; let y = cy; const step = Math.PI / spikes; ctx.beginPath(); ctx.moveTo(cx, cy - outerRadius); for (let i = 0; i < spikes; i++) { x = cx + Math.cos(rot) * outerRadius; y = cy + Math.sin(rot) * outerRadius; ctx.lineTo(x, y); rot += step; x = cx + Math.cos(rot) * innerRadius; y = cy + Math.sin(rot) * innerRadius; ctx.lineTo(x, y); rot += step; } ctx.lineTo(cx, cy - outerRadius); ctx.closePath(); ctx.fill(); }}let snowEffect;function enableSnow() { if (!snowEffect) { snowEffect = new SnowEffect(); window.snowEffect = snowEffect; } else { snowEffect.canvas.style.display = ''; }}function disableSnow() { if (snowEffect) { snowEffect.canvas.remove(); snowEffect = null; window.snowEffect = null; }}const snowCSS = `.snow-canvas { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 1; opacity: 0.8;}`;const snowStyle = document.createElement('style');snowStyle.textContent = snowCSS;document.head.appendChild(snowStyle);window.enableSnow = enableSnow;window.disableSnow = disableSnow;export { SnowEffect, enableSnow, disableSnow };'use strict';class AutumnLeavesEffect { constructor() { this.canvas = document.createElement('canvas'); this.canvas.className = 'autumn-leaves-canvas'; this.ctx = this.canvas.getContext('2d'); document.body.appendChild(this.canvas); this.resize(); this.sizeMultiplier = this.getSizeMultiplier(); window.addEventListener('resize', () => this.resize()); this.leaves = []; this.leafCount = Math.floor(window.innerWidth / 12); for (let i = 0; i < this.leafCount; i++) { this.leaves.push(this.createLeaf(true)); } this.handleMouseMove = this.handleMouseMove.bind(this); window.addEventListener('mousemove', this.handleMouseMove); window.addEventListener('touchmove', (e) => { if (e.touches && e.touches[0]) { this.handleMouseMove(e.touches[0]); } }, { passive: true }); this.wind = 0; this.windTarget = 0; this.lastWindChange = performance.now(); this.animate = this.animate.bind(this); requestAnimationFrame(this.animate); } resize() { this.canvas.width = window.innerWidth; this.canvas.height = window.innerHeight; this.sizeMultiplier = this.getSizeMultiplier(); } getSizeMultiplier() { const ratio = window.innerWidth / 768; return Math.min(Math.max(ratio, 0.6), 1.2); } createLeaf(randomY = false) { const leafTypes = ['maple', 'ginkgo']; const type = leafTypes[Math.floor(Math.random() * leafTypes.length)]; return { x: Math.random() * this.canvas.width, y: randomY ? Math.random() * this.canvas.height : -50, type: type, size: (8 + Math.random() * 16) * this.sizeMultiplier, speed: 0.8 + Math.random() * 1.2, opacity: 0.6 + Math.random() * 0.4, drift: Math.random() * 1 - 0.5, rotationSpeed: (Math.random() - 0.5) * 3, rotation: Math.random() * Math.PI * 2, swayAmplitude: 20 + Math.random() * 30, swaySpeed: 0.02 + Math.random() * 0.03, swayOffset: Math.random() * Math.PI * 2, color: this.getLeafColor(type) }; } getLeafColor(type) { if (type === 'maple') { const colors = [ { r: 200, g: 30, b: 30 }, { r: 220, g: 20, b: 60 }, { r: 255, g: 69, b: 0 }, { r: 255, g: 120, b: 0 }, { r: 255, g: 160, b: 0 } ]; return colors[Math.floor(Math.random() * colors.length)]; } else { const colors = [ { r: 255, g: 215, b: 0 }, { r: 255, g: 223, b: 0 }, { r: 255, g: 255, b: 0 }, { r: 238, g: 221, b: 130 }, { r: 255, g: 239, b: 145 } ]; return colors[Math.floor(Math.random() * colors.length)]; } } handleMouseMove(e) { const centerX = window.innerWidth / 2; const normalized = (e.clientX - centerX) / centerX; this.windTarget = normalized * 1.5; } animate() { const ctx = this.ctx; ctx.clearRect(0, 0, this.canvas.width, this.canvas.height); const now = performance.now(); if (now - this.lastWindChange > 3500) { this.windTarget = (Math.random() * 2 - 1) * 1.5; this.lastWindChange = now; } this.wind += (this.windTarget - this.wind) * 0.015; for (const leaf of this.leaves) { ctx.globalAlpha = leaf.opacity; const time = now * 0.001; const swayX = Math.sin(time * leaf.swaySpeed + leaf.swayOffset) * leaf.swayAmplitude; ctx.save(); ctx.translate(leaf.x + swayX, leaf.y); ctx.rotate(leaf.rotation); const { r, g, b } = leaf.color; ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${leaf.opacity})`; if (leaf.type === 'maple') { this.drawMapleLeaf(ctx, 0, 0, leaf.size); } else { this.drawGinkgoLeaf(ctx, 0, 0, leaf.size); } ctx.restore(); leaf.x += this.wind + leaf.drift; leaf.y += leaf.speed; leaf.rotation += leaf.rotationSpeed * 0.02; if (leaf.x < -50) leaf.x = this.canvas.width + 50; if (leaf.x > this.canvas.width + 50) leaf.x = -50; if (leaf.y > this.canvas.height + 50) { Object.assign(leaf, this.createLeaf()); } } requestAnimationFrame(this.animate); } drawMapleLeaf(ctx, cx, cy, size) { const s = size / 15; ctx.beginPath(); ctx.moveTo(cx, cy - 9 * s); ctx.lineTo(cx - 2 * s, cy - 6 * s); ctx.lineTo(cx - 7 * s, cy - 8 * s); ctx.lineTo(cx - 4 * s, cy - 3 * s); ctx.lineTo(cx - 9 * s, cy - 2 * s); ctx.lineTo(cx - 5 * s, cy + 1 * s); ctx.lineTo(cx - 7 * s, cy + 6 * s); ctx.lineTo(cx, cy + 3 * s); ctx.lineTo(cx + 7 * s, cy + 6 * s); ctx.lineTo(cx + 5 * s, cy + 1 * s); ctx.lineTo(cx + 9 * s, cy - 2 * s); ctx.lineTo(cx + 4 * s, cy - 3 * s); ctx.lineTo(cx + 7 * s, cy - 8 * s); ctx.lineTo(cx + 2 * s, cy - 6 * s); ctx.closePath(); ctx.fill(); } drawGinkgoLeaf(ctx, cx, cy, size) { const scale = size / 20; ctx.beginPath(); ctx.moveTo(cx, cy + 8 * scale); ctx.quadraticCurveTo(cx - 8 * scale, cy + 6 * scale, cx - 8 * scale, cy); ctx.quadraticCurveTo(cx - 8 * scale, cy - 6 * scale, cx, cy - 8 * scale); ctx.quadraticCurveTo(cx + 8 * scale, cy - 6 * scale, cx + 8 * scale, cy); ctx.quadraticCurveTo(cx + 8 * scale, cy + 6 * scale, cx, cy + 8 * scale); ctx.closePath(); ctx.fill(); ctx.globalCompositeOperation = 'destination-out'; ctx.beginPath(); ctx.moveTo(cx, cy); ctx.quadraticCurveTo(cx - 2 * scale, cy - 2 * scale, cx, cy - 4 * scale); ctx.quadraticCurveTo(cx + 2 * scale, cy - 2 * scale, cx, cy); ctx.closePath(); ctx.fill(); ctx.globalCompositeOperation = 'source-over'; }}let autumnLeavesEffect;function enableAutumnLeaves() { if (!autumnLeavesEffect) { autumnLeavesEffect = new AutumnLeavesEffect(); window.autumnLeavesEffect = autumnLeavesEffect; } else { autumnLeavesEffect.canvas.style.display = ''; }}function disableAutumnLeaves() { if (autumnLeavesEffect) { autumnLeavesEffect.canvas.remove(); autumnLeavesEffect = null; window.autumnLeavesEffect = null; }}const autumnLeavesCSS = `.autumn-leaves-canvas { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 1; opacity: 0.9;}`;const autumnLeavesStyle = document.createElement('style');autumnLeavesStyle.textContent = autumnLeavesCSS;document.head.appendChild(autumnLeavesStyle);window.enableAutumnLeaves = enableAutumnLeaves;window.disableAutumnLeaves = disableAutumnLeaves;export { AutumnLeavesEffect, enableAutumnLeaves, disableAutumnLeaves };'use strict';class SummerWillowEffect { constructor() { this.canvas = document.createElement('canvas'); this.canvas.className = 'summer-willow-canvas'; this.ctx = this.canvas.getContext('2d'); document.body.appendChild(this.canvas); this.resize(); window.addEventListener('resize', () => this.resize()); this.willowLeaves = []; this.leafCount = Math.floor(window.innerWidth / 10); for (let i = 0; i < this.leafCount; i++) { this.willowLeaves.push(this.createWillowLeaf(true)); } this.handleMouseMove = this.handleMouseMove.bind(this); window.addEventListener('mousemove', this.handleMouseMove); window.addEventListener('touchmove', (e) => { if (e.touches && e.touches[0]) { this.handleMouseMove(e.touches[0]); } }, { passive: true }); this.wind = 0; this.windTarget = 0; this.lastWindChange = performance.now(); this.animate = this.animate.bind(this); requestAnimationFrame(this.animate); } resize() { this.canvas.width = window.innerWidth; this.canvas.height = window.innerHeight; } createWillowLeaf(randomY = false) { return { x: Math.random() * this.canvas.width, y: randomY ? Math.random() * this.canvas.height : -30, length: 15 + Math.random() * 25, width: 3 + Math.random() * 4, speed: 0.4 + Math.random() * 0.8, opacity: 0.5 + Math.random() * 0.4, drift: Math.random() * 2 - 1, rotationSpeed: (Math.random() - 0.5) * 2.5, rotation: Math.random() * Math.PI * 2, swayAmplitude: 50 + Math.random() * 60, swaySpeed: 0.02 + Math.random() * 0.025, swayOffset: Math.random() * Math.PI * 2, curvature: 0.1 + Math.random() * 0.3, windResistance: 0.3 + Math.random() * 0.7, turbulence: Math.random() * 0.5, color: this.getWillowColor() }; } handleMouseMove(e) { const centerX = window.innerWidth / 2; const normalized = (e.clientX - centerX) / centerX; this.windTarget = normalized * 3.5; } getWillowColor() { const colors = [ { r: 50, g: 150, b: 50 }, { r: 60, g: 180, b: 60 }, { r: 40, g: 140, b: 80 }, { r: 70, g: 160, b: 70 }, { r: 80, g: 200, b: 80 }, { r: 45, g: 130, b: 90 }, { r: 90, g: 190, b: 90 } ]; return colors[Math.floor(Math.random() * colors.length)]; } animate() { const ctx = this.ctx; ctx.clearRect(0, 0, this.canvas.width, this.canvas.height); const now = performance.now(); if (now - this.lastWindChange > 3000) { this.windTarget = (Math.random() * 2 - 1) * 3.5; this.lastWindChange = now; } this.wind += (this.windTarget - this.wind) * 0.02; for (const leaf of this.willowLeaves) { ctx.globalAlpha = leaf.opacity; const time = now * 0.001; const swayX = Math.sin(time * leaf.swaySpeed + leaf.swayOffset) * leaf.swayAmplitude; ctx.save(); ctx.translate(leaf.x + swayX, leaf.y); const windTilt = this.wind * 0.1; ctx.rotate(leaf.rotation + windTilt); const { r, g, b } = leaf.color; ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${leaf.opacity})`; ctx.strokeStyle = `rgba(${r - 20}, ${g - 20}, ${b - 10}, ${leaf.opacity * 0.8})`; ctx.lineWidth = 0.5; this.drawWillowLeaf(ctx, 0, 0, leaf.length, leaf.width, leaf.curvature); ctx.restore(); const windForce = this.wind * leaf.windResistance; const turbulenceX = Math.sin(now * 0.001 * leaf.turbulence) * 0.5; const turbulenceY = Math.cos(now * 0.0015 * leaf.turbulence) * 0.3; leaf.x += windForce + leaf.drift + turbulenceX; leaf.y += leaf.speed + Math.abs(windForce) * 0.1 + turbulenceY; leaf.rotation += leaf.rotationSpeed * 0.02 + Math.abs(windForce) * 0.01; if (leaf.x < -60) leaf.x = this.canvas.width + 60; if (leaf.x > this.canvas.width + 60) leaf.x = -60; if (leaf.y > this.canvas.height + 60) { Object.assign(leaf, this.createWillowLeaf()); } } requestAnimationFrame(this.animate); } drawWillowLeaf(ctx, cx, cy, length, width, curvature) { ctx.beginPath(); const halfLength = length / 2; const halfWidth = width / 2; ctx.moveTo(cx, cy - halfLength); ctx.quadraticCurveTo( cx + halfWidth + curvature * 10, cy - halfLength * 0.3, cx + halfWidth, cy ); ctx.quadraticCurveTo( cx + halfWidth - curvature * 5, cy + halfLength * 0.3, cx, cy + halfLength ); ctx.quadraticCurveTo( cx - halfWidth + curvature * 5, cy + halfLength * 0.3, cx - halfWidth, cy ); ctx.quadraticCurveTo( cx - halfWidth - curvature * 10, cy - halfLength * 0.3, cx, cy - halfLength ); ctx.closePath(); ctx.fill(); ctx.beginPath(); ctx.moveTo(cx, cy - halfLength * 0.8); ctx.quadraticCurveTo( cx + curvature * 3, cy, cx, cy + halfLength * 0.8 ); ctx.stroke(); }}let summerWillowEffect;function enableSummerWillow() { if (!summerWillowEffect) { summerWillowEffect = new SummerWillowEffect(); window.summerWillowEffect = summerWillowEffect; } else { summerWillowEffect.canvas.style.display = ''; }}function disableSummerWillow() { if (summerWillowEffect) { summerWillowEffect.canvas.remove(); summerWillowEffect = null; window.summerWillowEffect = null; }}const summerWillowCSS = `.summer-willow-canvas { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 1; opacity: 0.85;}`;const summerWillowStyle = document.createElement('style');summerWillowStyle.textContent = summerWillowCSS;document.head.appendChild(summerWillowStyle);window.enableSummerWillow = enableSummerWillow;window.disableSummerWillow = disableSummerWillow;export { SummerWillowEffect, enableSummerWillow, disableSummerWillow };'use strict';class RainEffect { constructor() { this.canvas = document.createElement('canvas'); this.canvas.className = 'rain-canvas'; this.ctx = this.canvas.getContext('2d'); document.body.appendChild(this.canvas); this.resize(); window.addEventListener('resize', () => this.resize()); this.drops = []; this.dropCount = Math.floor(window.innerWidth / 2.5); for (let i = 0; i < this.dropCount; i++) { this.drops.push(this.createDrop(true)); } this.handleMouseMove = this.handleMouseMove.bind(this); window.addEventListener('mousemove', this.handleMouseMove); window.addEventListener('touchmove', (e) => { if (e.touches && e.touches[0]) { this.handleMouseMove(e.touches[0]); } }, { passive: true }); this.wind = 0; this.windTarget = 0; this.lastWindChange = performance.now(); this.animate = this.animate.bind(this); requestAnimationFrame(this.animate); } resize() { this.canvas.width = window.innerWidth; this.canvas.height = window.innerHeight; } createDrop(randomY = false) { return { x: Math.random() * this.canvas.width, y: randomY ? Math.random() * this.canvas.height : -20, length: 15 + Math.random() * 25, speed: 3 + Math.random() * 5, opacity: 0.3 + Math.random() * 0.4, thickness: 0.8 + Math.random() * 0.7 }; } handleMouseMove(e) { const centerX = window.innerWidth / 2; const normalized = (e.clientX - centerX) / centerX; this.windTarget = normalized * 2; } animate() { const ctx = this.ctx; ctx.clearRect(0, 0, this.canvas.width, this.canvas.height); ctx.lineCap = 'round'; const now = performance.now(); if (now - this.lastWindChange > 3000) { this.windTarget = (Math.random() * 2 - 1) * 2; this.lastWindChange = now; } this.wind += (this.windTarget - this.wind) * 0.015; for (const d of this.drops) { ctx.globalAlpha = d.opacity; ctx.lineWidth = d.thickness; ctx.strokeStyle = `rgba(200, 220, 255, ${d.opacity})`; ctx.beginPath(); ctx.moveTo(d.x, d.y); ctx.lineTo(d.x + this.wind * 3, d.y + d.length); ctx.stroke(); if (d.y > this.canvas.height - 50 && Math.random() < 0.02) { ctx.globalAlpha = d.opacity * 0.5; ctx.strokeStyle = `rgba(123, 167, 212, ${d.opacity * 0.5})`; ctx.lineWidth = 0.5; ctx.beginPath(); ctx.arc(d.x, this.canvas.height - 10, 2 + Math.random() * 3, 0, Math.PI * 2); ctx.stroke(); } d.x += this.wind * (d.speed / 4); d.y += d.speed; if (d.x < -30) d.x = this.canvas.width + 30; if (d.x > this.canvas.width + 30) d.x = -30; if (d.y > this.canvas.height + 10) { Object.assign(d, this.createDrop()); } } requestAnimationFrame(this.animate); }}let rainEffect;function enableRain() { if (!rainEffect) { rainEffect = new RainEffect(); window.rainEffect = rainEffect; } else { rainEffect.canvas.style.display = ''; }}function disableRain() { if (rainEffect) { rainEffect.canvas.remove(); rainEffect = null; window.rainEffect = null; }}window.handleLogoClick = (event) => { event.preventDefault(); if (typeof scrollToSection === 'function') { scrollToSection('home'); } else { const homeSection = document.getElementById('home'); if (homeSection) { homeSection.scrollIntoView({ behavior: 'smooth' }); } } if (window.seasonsGallery && typeof window.seasonsGallery.switchToSeason === 'function') { setTimeout(() => { window.seasonsGallery.currentSeason = 'tsuyu'; document.body.setAttribute('data-season', 'tsuyu'); const hero = document.querySelector('.hero'); if (hero) { hero.style.backgroundImage = `linear-gradient(rgba(0,0,0,0.4), rgba(0,0,0,0.4)), url('./img/秀歌-メインビジュアル.webp')`; hero.style.backgroundPosition = 'left top'; const heroContent = hero.querySelector('.hero-content'); if (heroContent) { heroContent.style.paddingTop = ''; } } if (typeof window.enableRain === 'function') { window.enableRain(); } window.seasonsGallery.updateSeasonButtons('summer'); window.seasonsGallery.updateSeasonPanels('summer', false); window.seasonsGallery.updateURL('tsuyu'); }, 300); } const navMenu = document.getElementById('nav-menu'); const navToggle = document.getElementById('nav-toggle'); if (navMenu && navMenu.classList.contains('active')) { navMenu.classList.remove('active'); navToggle.classList.remove('active'); navToggle.setAttribute('aria-expanded', 'false'); document.body.style.overflow = ''; }};export { RainEffect, enableRain, disableRain, handleLogoClick };class WaterRippleEffect { constructor() { this.container = document.getElementById('ripple-container'); this.isActive = true; this.lastRippleTime = 0; this.throttleDelay = 400; this.maxRipples = 12; this.ripples = []; this.petalLimit = 100; this.frameTime = 0; this.performanceOptimized = false; this.init(); } init() { if (!this.container) { console.error('Ripple container not found'); return; } this.checkUserPreferences(); this.bindEvents(); } checkUserPreferences() { const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches; if (prefersReducedMotion) { this.isActive = false; this.container.style.display = 'none'; return; } if (navigator.hardwareConcurrency && navigator.hardwareConcurrency < 4) { this.throttleDelay = 600; this.maxRipples = 8; } } bindEvents() { if (!this.isActive) return; document.addEventListener('mousemove', (e) => this.handleMouseMove(e)); document.addEventListener('click', (e) => this.handleClick(e)); document.addEventListener('touchstart', (e) => this.handleTouch(e), { passive: true }); window.matchMedia('(prefers-reduced-motion: reduce)').addEventListener('change', (e) => { if (e.matches) { this.disable(); } else { this.enable(); } }); setInterval(() => this.cleanupRipples(), 2000); this.monitorPerformance(); } handleMouseMove(e) { if (!this.isActive || !this.shouldCreateRipple()) return; this.createTranquilRipples(e.clientX, e.clientY); this.lastRippleTime = Date.now(); } handleClick(e) { if (!this.isActive) return; const { clientX: x, clientY: y } = e; this.createLuxuriousClickEffect(x, y); } handleTouch(e) { if (!this.isActive || !e.touches[0]) return; const touch = e.touches[0]; this.createRipple(touch.clientX, touch.clientY, 'medium'); } shouldCreateRipple() { const now = Date.now(); return (now - this.lastRippleTime) > this.throttleDelay; } createRipple(x, y, size = 'medium', color = 'default') { if (!this.isActive || this.ripples.length >= this.maxRipples) return; const ripple = document.createElement('div'); ripple.className = `ripple ${size} ${color}`; const sizeMap = { small: Math.random() * 120 + 80, medium: Math.random() * 200 + 150, large: Math.random() * 300 + 200, huge: Math.random() * 400 + 300 }; const rippleSize = sizeMap[size] || sizeMap.medium; ripple.style.width = `${rippleSize}px`; ripple.style.height = `${rippleSize}px`; ripple.style.left = `${x - rippleSize / 2}px`; ripple.style.top = `${y - rippleSize / 2}px`; const rotation = Math.random() * 360; ripple.style.transform = `scale(0) rotate(${rotation}deg)`; if (color === 'rainbow') { const hue = Math.random() * 360; ripple.style.background = `radial-gradient(circle, hsla(${hue}, 80%, 70%, 0.8) 0%, hsla(${hue + 60}, 70%, 60%, 0.4) 40%, transparent 80%)`; } else if (color === 'gold') { ripple.style.background = 'radial-gradient(circle, rgba(255, 215, 0, 0.9) 0%, rgba(255, 165, 0, 0.6) 30%, rgba(255, 140, 0, 0.3) 60%, transparent 90%)'; } this.container.appendChild(ripple); this.ripples.push({ element: ripple, createdAt: Date.now() }); const animationDuration = size === 'huge' ? 3500 : size === 'large' ? 2800 : size === 'small' ? 1200 : 1800; setTimeout(() => { this.removeRipple(ripple); }, animationDuration); } removeRipple(rippleElement) { if (rippleElement && rippleElement.parentNode) { rippleElement.parentNode.removeChild(rippleElement); } this.ripples = this.ripples.filter(ripple => ripple.element !== rippleElement); } cleanupRipples() { const now = Date.now(); const oldRipples = this.ripples.filter(ripple => { return (now - ripple.createdAt) > 3000; }); oldRipples.forEach(ripple => { this.removeRipple(ripple.element); }); } createTranquilRipples(x, y) { this.createRipple(x, y, 'small', 'elegant'); if (Math.random() < 0.12) { setTimeout(() => { const offsetX = (Math.random() * 20 - 10); const offsetY = (Math.random() * 20 - 10); this.createRipple(x + offsetX, y + offsetY, 'small', 'subtle'); }, Math.random() * 500 + 200); } if (Math.random() < 0.05) { setTimeout(() => { this.createRipple(x, y, 'medium', 'subtle'); }, Math.random() * 800 + 400); } } createZenClickEffect(x, y) { this.createInkDrops(x, y, 6); setTimeout(() => { this.createFloatingLeaves(x, y, 4); }, 200); setTimeout(() => { this.createSubtleGlow(x, y, 120); }, 100); this.createTranquilDots(x, y, 8); } createInkDrops(x, y, count) { if (!this.container) return; for (let i = 0; i < count; i++) { const drop = document.createElement('div'); drop.className = 'ink-drop'; const size = Math.random() * 4 + 3; drop.style.width = `${size}px`; drop.style.height = `${size}px`; drop.style.left = `${x - size / 2}px`; drop.style.top = `${y - size / 2}px`; const angle = (360 / count) * i + (Math.random() * 60 - 30); const distance = 30 + Math.random() * 50; const dx = Math.cos(angle * Math.PI / 180) * distance; const dy = Math.sin(angle * Math.PI / 180) * distance; const duration = (Math.random() * 0.8 + 1.5).toFixed(2); drop.style.setProperty('--dx', `${dx}px`); drop.style.setProperty('--dy', `${dy}px`); drop.style.animationDuration = `${duration}s`; this.container.appendChild(drop); setTimeout(() => drop.remove(), duration * 1000); } } createSubtleGlow(x, y, size) { if (!this.container) return; const glow = document.createElement('div'); glow.className = 'subtle-glow'; glow.style.width = `${size}px`; glow.style.height = `${size}px`; glow.style.left = `${x - size / 2}px`; glow.style.top = `${y - size / 2}px`; this.container.appendChild(glow); setTimeout(() => glow.remove(), 2000); } createFloatingLeaves(x, y, count) { if (!this.container) return; for (let i = 0; i < count; i++) { const leaf = document.createElement('div'); leaf.className = 'floating-leaf'; const width = Math.random() * 4 + 2; const height = Math.random() * 3 + 2; leaf.style.width = `${width}px`; leaf.style.height = `${height}px`; leaf.style.left = `${x - width / 2}px`; leaf.style.top = `${y - height / 2}px`; const angle = Math.random() * 360; const distance = 40 + Math.random() * 60; const dx = Math.cos(angle * Math.PI / 180) * distance; const dy = Math.sin(angle * Math.PI / 180) * distance; const duration = (Math.random() * 1.5 + 2).toFixed(2); leaf.style.setProperty('--dx', `${dx}px`); leaf.style.setProperty('--dy', `${dy}px`); leaf.style.animationDuration = `${duration}s`; const leafAngle = Math.random() * 360; leaf.style.setProperty('--leaf-angle', `${leafAngle}deg`); this.container.appendChild(leaf); setTimeout(() => leaf.remove(), duration * 1000); } } createTranquilDots(x, y, count) { if (!this.container) return; for (let i = 0; i < count; i++) { const dot = document.createElement('div'); dot.className = 'tranquil-dot'; dot.style.left = `${x - 1}px`; dot.style.top = `${y - 1}px`; const angle = (360 / count) * i; const distance = 20 + Math.random() * 40; const dx = Math.cos(angle * Math.PI / 180) * distance; const dy = Math.sin(angle * Math.PI / 180) * distance; const duration = (Math.random() * 0.5 + 1).toFixed(2); dot.style.setProperty('--dx', `${dx}px`); dot.style.setProperty('--dy', `${dy}px`); dot.style.animationDuration = `${duration}s`; this.container.appendChild(dot); setTimeout(() => dot.remove(), duration * 1000); } } createSakuraBurst(x, y, count = 8) { if (!this.container) return; for (let i = 0; i < count; i++) { const petal = document.createElement('div'); petal.className = 'sakura-petal'; const size = Math.random() * 12 + 8; petal.style.width = `${size}px`; petal.style.height = `${size}px`; petal.style.left = `${x - size / 2}px`; petal.style.top = `${y - size / 2}px`; const angle = Math.random() * 360; const distance = 80 + Math.random() * 80; const dx = Math.cos(angle * Math.PI / 180) * distance; const dy = Math.sin(angle * Math.PI / 180) * distance; const duration = (Math.random() * 1 + 2).toFixed(2); petal.style.setProperty('--dx', `${dx}px`); petal.style.setProperty('--dy', `${dy}px`); petal.style.animationDuration = `${duration}s`; this.container.appendChild(petal); setTimeout(() => petal.remove(), duration * 1000); } } createLuxuriousClickEffect(x, y) { this.createRipple(x, y, 'huge', 'gold'); this.createSakuraBurst(x, y, 14); this.createKabukiSwirls(x, y, 2); this.createFloatingElements(x, y, 12); this.createSubtleGlow(x, y, 200); this.createClickFlash(x, y); } createKabukiSwirls(x, y, count = 2) { if (!this.container) return; for (let i = 0; i < count; i++) { const swirl = document.createElement('div'); swirl.className = 'kabuki-swirl'; const size = 40 + Math.random() * 20; swirl.style.width = `${size}px`; swirl.style.height = `${size}px`; swirl.style.left = `${x - size / 2}px`; swirl.style.top = `${y - size / 2}px`; swirl.style.animationDuration = `${(Math.random() * 0.4 + 0.8).toFixed(2)}s`; this.container.appendChild(swirl); setTimeout(() => swirl.remove(), 1000); } } createFloatingElements(x, y, count = 6) { if (!this.container) return; const activeParticles = this.container.querySelectorAll('.refined-particle').length; if (activeParticles >= 15) return; for (let i = 0; i < count; i++) { const particle = document.createElement('div'); particle.className = 'refined-particle'; const size = Math.random() * 3 + 2; particle.style.width = `${size}px`; particle.style.height = `${size}px`; particle.style.left = `${x - size / 2}px`; particle.style.top = `${y - size / 2}px`; const angle = Math.random() * 360; const distance = 60 + Math.random() * 60; const dx = Math.cos(angle * Math.PI / 180) * distance; const dy = Math.sin(angle * Math.PI / 180) * distance; const dur = (Math.random() * 1.2 + 2).toFixed(2); particle.style.setProperty('--dx', `${dx}px`); particle.style.setProperty('--dy', `${dy}px`); particle.style.animationDuration = `${dur}s`; const opacity = 0.3 + Math.random() * 0.3; particle.style.background = `radial-gradient( circle, rgba(75, 85, 99, ${opacity}) 0%, rgba(107, 114, 128, ${opacity * 0.6}) 50%, transparent 100% )`; this.container.appendChild(particle); setTimeout(() => particle.remove(), dur * 1000); } } createClickFlash(x, y){ if(!this.container) return; const flash=document.createElement('div'); flash.className='click-flash'; const size=20; flash.style.width=`${size}px`; flash.style.height=`${size}px`; flash.style.left=`${x-size/2}px`; flash.style.top=`${y-size/2}px`; this.container.appendChild(flash); setTimeout(()=>flash.remove(),600); } enable() { this.isActive = true; if (this.container) { this.container.style.display = 'block'; } } disable() { this.isActive = false; if (this.container) { this.container.style.display = 'none'; } this.ripples.forEach(ripple => { this.removeRipple(ripple.element); }); } toggle() { if (this.isActive) { this.disable(); } else { this.enable(); } } createCustomRipple(x, y, color, size = 200) { if (!this.isActive) return; const ripple = document.createElement('div'); ripple.className = 'ripple'; ripple.style.background = `radial-gradient(circle, ${color}40 0%, ${color}20 20%, ${color}10 40%, transparent 80%)`; ripple.style.width = `${size}px`; ripple.style.height = `${size}px`; ripple.style.left = `${x - size / 2}px`; ripple.style.top = `${y - size / 2}px`; this.container.appendChild(ripple); setTimeout(() => { this.removeRipple(ripple); }, 1500); } monitorPerformance() { let frameCount = 0; let lastTime = performance.now(); const checkPerformance = (currentTime) => { frameCount++; if (currentTime - lastTime >= 1000) { const fps = Math.round((frameCount * 1000) / (currentTime - lastTime)); if (fps < 50 && !this.performanceOptimized) { this.optimizeForPerformance(); } frameCount = 0; lastTime = currentTime; } requestAnimationFrame(checkPerformance); }; requestAnimationFrame(checkPerformance); } optimizeForPerformance() { this.performanceOptimized = true; this.throttleDelay = Math.max(this.throttleDelay * 1.5, 600); this.maxRipples = Math.max(this.maxRipples - 3, 6); while (this.ripples.length > this.maxRipples) { const oldestRipple = this.ripples.shift(); this.removeRipple(oldestRipple.element); } }}function toggleRipples() { if (window.waterRipples) { window.waterRipples.toggle(); }}function createCustomRipple(x, y, color, size) { if (window.waterRipples) { window.waterRipples.createCustomRipple(x, y, color, size); }}window.WaterRippleEffect = WaterRippleEffect;window.toggleRipples = toggleRipples;window.createCustomRipple = createCustomRipple;window.addEventListener('DOMContentLoaded', () => { if (typeof Navigation !== 'undefined') { window.navigation = new Navigation(); } if (typeof SeasonsGallery !== 'undefined') { window.seasonsGallery = new SeasonsGallery(); } if (typeof initSeasonSelector === 'function') { initSeasonSelector(); } if (typeof WaterRippleEffect !== 'undefined') { window.waterRipples = new WaterRippleEffect(); } if (typeof ShukaApp !== 'undefined') { window.shukaApp = new ShukaApp(); } const logoLink = document.getElementById('logo-link'); if (logoLink && typeof handleLogoClick === 'function') { logoLink.addEventListener('click', handleLogoClick); }});
